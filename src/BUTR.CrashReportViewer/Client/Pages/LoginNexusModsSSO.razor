@page "/login-nexusmods-sso"
@inject IJSRuntime _jsRuntime;
@inject NavigationManager _navigationManager
@inject ILocalStorageService _localStorage
@inject BackendAPIClient _backendApiClient
@inject DefaultJsonSerializer _jsonSerializer

<!--https://jsfiddle.net/bootstrapious/j80aheo9/-->
<div class="container">
    <div class="row">
        <div class="col-lg-10 col-xl-7 mx-auto">
            <div class="card">
                <h4 class="card-header text-center">NexusMods Log In</h4>
                <div class="card-body">
                    @if (_url is null)
                    {
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    }
                    else
                    {
                        <button type="submit" class="btn btn-primary text-uppercase mb-2" @onclick="OpenUrl">
                            @if (_url is null)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                            }
                            Open NexusMods For Authorization
                        </button>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

@code {

    private record SSORequest([property: JsonPropertyName("id")] Guid Id, [property: JsonPropertyName("token")] string? Token, [property: JsonPropertyName("protocol")] int Protocol);
    private record SSOResponse([property: JsonPropertyName("success")] bool Success, [property: JsonPropertyName("data")] SSOResponseData? Data);
    private record SSOResponseData([property: JsonPropertyName("connection_token")] string? ConnectionToken, [property: JsonPropertyName("api_key")] string? ApiKey);

    private readonly CancellationTokenSource _cancellationTokenSource = new();
    private readonly ClientWebSocket _client = new();
    private Task _receiveTask = default!;
    private bool _isLoading;
    private string? _url;

    private async Task OpenUrl() => await _jsRuntime.InvokeAsync<string>("open", _url, "_blank");

    protected override async Task OnInitializedAsync()
    {
        // if (!await _localStorage.ContainKeyAsync("sso_uuid"))
        await _localStorage.SetItemAsync("sso_uuid", Guid.NewGuid(), _cancellationTokenSource.Token);

        var uuid = await _localStorage.GetItemAsync<Guid>("sso_uuid");
        var token = await _localStorage.GetItemAsync<string>("sso_token");

        var request = _jsonSerializer.SerializeToUtf8Bytes(new SSORequest(uuid, token, 2));

        await _client.ConnectAsync(new Uri("wss://sso.nexusmods.com"), _cancellationTokenSource.Token);
        _receiveTask = ReceiveLoop();
        await _client.SendAsync(request, WebSocketMessageType.Text, true, _cancellationTokenSource.Token);
    }

    async Task ReceiveLoop()
    {
        try
        {
            var buffer = new ArraySegment<byte>(new byte[1024]);
            var sb = new StringBuilder();
            while (!_cancellationTokenSource.IsCancellationRequested)
            {
                // Note that the received block might only be part of a larger message. If this applies in your scenario,
                // check the received.EndOfMessage and consider buffering the blocks until that property is true.
                // Or use a higher-level library such as SignalR.
                var received = await _client.ReceiveAsync(buffer, _cancellationTokenSource.Token);
                if (received.MessageType == WebSocketMessageType.Close)
                    return;

                sb.Append(Encoding.UTF8.GetString(buffer.AsSpan(0, received.Count)));
                if (received.EndOfMessage)
                {
                    var text = sb.ToString();
                    sb.Clear();

                    var response = _jsonSerializer.Deserialize<SSOResponse?>(text);
                    if (response is not null && response.Success && response.Data is not null)
                    {
                        if (response.Data.ConnectionToken is not null)
                        {
                            var uuid = await _localStorage.GetItemAsync<Guid>("sso_uuid");
                            var applicationSlug = "vortex";
                            var url = $"https://www.nexusmods.com/sso?id={uuid}&application={applicationSlug}";
                            //await _jsRuntime.InvokeAsync<string>("open", url, "_blank");
                            _url = url;
                            StateHasChanged();
                        }

                        if (response.Data.ApiKey is not null)
                        {
                            _isLoading = true;

                            try
                            {
                                var result = await _backendApiClient.Authenticate(response.Data.ApiKey);
                                if (result is null)
                                {
                                    _isLoading = false;
                                    StateHasChanged();
                                }
                                else
                                {
                                    await _localStorage.SetItemAsStringAsync("token", result);
                                    _navigationManager.NavigateTo(_navigationManager.QueryString("returnUrl") ?? "crash-reports-viewer", true);
                                }
                            }
                            catch
                            {
                                _isLoading = true;
                                StateHasChanged();
                            }
                        }
                    }

                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
    }

    public async ValueTask DisposeAsync()
    {
        _cancellationTokenSource.Cancel();
        await _client.CloseAsync(WebSocketCloseStatus.NormalClosure, "Bye", CancellationToken.None);
        await Task.WhenAny(_receiveTask, Task.Delay(2000));
        _client.Dispose();
    }
}
